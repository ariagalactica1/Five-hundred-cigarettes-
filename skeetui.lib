--[[
Gamesense-like Drawing UI Library
- Client-side / local only (Drawing API)
- Features:
  * Window with title / small sidebar
  * Tabs (easy add)
  * Buttons, Toggles, Sliders
  * Resizable (drag lower-right)
  * Automatic text scaling when window resized
  * Theme customization (colors provided; matches reference image)
  * Mouse hover + click interactions
  * Minimal dependency: Drawing, RunService, UserInputService
--]]

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

-- Helper: clamp
local function clamp(v, a, b) if v < a then return a elseif v > b then return b else return v end end

-- Helper: make Color3 from hex
local function hexToColor3(hex)
    hex = hex:gsub("#","")
    if #hex == 3 then -- expand shorthand
        hex = hex:sub(1,1)..hex:sub(1,1) .. hex:sub(2,2)..hex:sub(2,2) .. hex:sub(3,3)..hex:sub(3,3)
    end
    local r = tonumber(hex:sub(1,2),16)/255
    local g = tonumber(hex:sub(3,4),16)/255
    local b = tonumber(hex:sub(5,6),16)/255
    return Color3.new(r,g,b)
end

-- DEFAULT THEME (matched to reference image as closely as possible)
local DEFAULT_THEME = {
    Background = hexToColor3("#0f1415"),      -- window background
    Panel = hexToColor3("#1f2627"),           -- inner panels
    PanelAccent = hexToColor3("#252a2b"),     -- slightly lighter panel
    Text = Color3.new(0.94,0.96,0.98),        -- near-white text
    MutedText = Color3.new(0.75,0.78,0.8),
    Accent = hexToColor3("#4fe07a"),          -- bright green accent for toggles/sliders
    SliderFill = hexToColor3("#3bd06b"),
    Sidebar = hexToColor3("#111618"),
    Highlight = hexToColor3("#2a2f30"),
}

-- Drawing helpers
local DrawingAPI = {}
function DrawingAPI.newRect()
    local r = Drawing.new("Square")
    r.Filled = true
    r.Transparency = 1
    r.ZIndex = 1
    return r
end
function DrawingAPI.newText()
    local t = Drawing.new("Text")
    t.Center = false
    t.Outline = true
    t.OutlineColor = Color3.new(0,0,0)
    t.Visible = true
    t.ZIndex = 2
    return t
end
function DrawingAPI.newLine()
    local l = Drawing.new("Line")
    l.Thickness = 1
    l.Visible = true
    l.ZIndex = 2
    return l
end
function DrawingAPI.newCircle()
    local c = Drawing.new("Circle")
    c.Filled = true
    c.NumSides = 100
    c.Visible = true
    c.ZIndex = 2
    return c
end

-- UI Library root
local UI = {}
UI.__index = UI

function UI.new(opts)
    opts = opts or {}
    local self = setmetatable({}, UI)

    self.theme = opts.theme or DEFAULT_THEME
    -- default window properties (size/pos scale to screen)
    local screenW, screenH = workspace.CurrentCamera.ViewportSize.X, workspace.CurrentCamera.ViewportSize.Y
    self.pos = opts.pos or Vector2.new(60, 40)
    self.size = opts.size or Vector2.new(820, 520)
    self.minSize = Vector2.new(520, 340)
    self.title = opts.title or "GAMESENSE"
    self.tabs = {}
    self.activeTab = nil
    self.dragging = false
    self.resizing = false
    self.resizerSize = 18
    self.mouseDown = false
    self.inputs = {}

    -- Drawing elements
    self.canvas = {}
    self:_createBaseElements()
    self:_connectInput()
    self:_startRender()

    return self
end

-- INTERNAL: create base drawing shapes
function UI:_createBaseElements()
    -- main window rectangle
    local bg = DrawingAPI.newRect()
    bg.Color = self.theme.Background
    bg.Size = Vector2.new(self.size.X, self.size.Y)
    bg.Position = Vector2.new(self.pos.X, self.pos.Y)
    bg.Filled = true
    bg.Visible = true
    self.canvas.bg = bg

    -- left sidebar
    local sidebar = DrawingAPI.newRect()
    sidebar.Color = self.theme.Sidebar
    sidebar.Size = Vector2.new(180, self.size.Y)
    sidebar.Position = Vector2.new(self.pos.X, self.pos.Y)
    self.canvas.sidebar = sidebar

    -- content panel
    local contentPanel = DrawingAPI.newRect()
    contentPanel.Color = self.theme.Panel
    contentPanel.Size = Vector2.new(self.size.X - 180 - 20, self.size.Y - 32)
    contentPanel.Position = Vector2.new(self.pos.X + 180 + 12, self.pos.Y + 22)
    self.canvas.content = contentPanel

    -- Top bar text (title)
    local titleText = DrawingAPI.newText()
    titleText.Text = self.title
    titleText.Size = 24
    titleText.Position = Vector2.new(self.pos.X + 12, self.pos.Y + 8)
    titleText.Color = self.theme.Text
    titleText.Visible = true
    self.canvas.title = titleText

    -- Save/gear small icons (simple circles representing icons)
    local smallCircle = DrawingAPI.newCircle()
    smallCircle.Position = Vector2.new(self.pos.X + self.size.X - 24, self.pos.Y + 14)
    smallCircle.Radius = 8
    smallCircle.Color = self.theme.PanelAccent
    self.canvas.saveIcon = smallCircle

    local gearCircle = DrawingAPI.newCircle()
    gearCircle.Position = Vector2.new(self.pos.X + self.size.X - 46, self.pos.Y + 14)
    gearCircle.Radius = 8
    gearCircle.Color = self.theme.PanelAccent
    self.canvas.gearIcon = gearCircle

    -- Tab list container (draw tab names on sidebar)
    self.canvas.tabTexts = {}

    -- content items per-tab are stored in tab.children
end

-- create tab, returns tab object
function UI:CreateTab(name)
    local tab = {name = name, children = {}, id = HttpService:GenerateGUID(false)}
    table.insert(self.tabs, tab)
    if not self.activeTab then
        self.activeTab = tab
    end
    return setmetatable(tab, {
        __index = {
            AddButton = function(selfTab, label, callback)
                table.insert(selfTab.children, {type="button", label=label, cb=callback, id=HttpService:GenerateGUID(false)})
                return selfTab
            end,
            AddToggle = function(selfTab, label, default, callback)
                table.insert(selfTab.children, {type="toggle", label=label, state=default and true or false, cb=callback, id=HttpService:GenerateGUID(false)})
                return selfTab
            end,
            AddSlider = function(selfTab, label, min, max, default, callback)
                table.insert(selfTab.children, {type="slider", label=label, min=min, max=max, value=default, cb=callback, id=HttpService:GenerateGUID(false)})
                return selfTab
            end,
        }
    })
end

-- Switch active tab by index or name
function UI:SetActiveTab(idOrName)
    for _,t in ipairs(self.tabs) do
        if t.id == idOrName or t.name == idOrName then
            self.activeTab = t
            break
        end
    end
end

-- Theme change
function UI:SetTheme(tbl)
    for k,v in pairs(tbl) do
        if self.theme[k] ~= nil then
            self.theme[k] = v
        end
    end
    -- apply basic color updates
    self.canvas.bg.Color = self.theme.Background
    self.canvas.sidebar.Color = self.theme.Sidebar
    self.canvas.content.Color = self.theme.Panel
    self.canvas.title.Color = self.theme.Text
    self.canvas.saveIcon.Color = self.theme.PanelAccent
    self.canvas.gearIcon.Color = self.theme.PanelAccent
end

-- Input handlers
function UI:_connectInput()
    local mousePos = Vector2.new(0,0)
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.mouseDown = true
            local mpos = UserInputService:GetMouseLocation()
            mousePos = Vector2.new(mpos.X, mpos.Y)
            -- check if clicked in header area to start dragging
            if self:_pointInRect(mousePos, self.pos + Vector2.new(0,0), Vector2.new(self.size.X, 28)) then
                self.dragging = true
                self.dragOffset = mousePos - self.pos
            end
            -- check if clicked in resizer area
            local resPos = self.pos + self.size - Vector2.new(self.resizerSize, self.resizerSize)
            if self:_pointInRect(mousePos, resPos, Vector2.new(self.resizerSize, self.resizerSize)) then
                self.resizing = true
                self.resizeStart = mousePos
                self.startSize = self.size
            end

            -- click interactions for sidebar items / controls
            self:_handleClick(mousePos)
        end
    end)
    UserInputService.InputEnded:Connect(function(input, processed)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.mouseDown = false
            self.dragging = false
            self.resizing = false
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            local m = UserInputService:GetMouseLocation()
            local mp = Vector2.new(m.X, m.Y)
            if self.dragging then
                self.pos = mp - self.dragOffset
            elseif self.resizing then
                local delta = mp - self.resizeStart
                local newSize = self.startSize + Vector2.new(delta.X, delta.Y)
                newSize = Vector2.new(math.max(self.minSize.X, newSize.X), math.max(self.minSize.Y, newSize.Y))
                self.size = newSize
            end
        end
    end)
end

-- check point in rect
function UI:_pointInRect(pt, rectPos, rectSize)
    return pt.X >= rectPos.X and pt.Y >= rectPos.Y and pt.X <= rectPos.X + rectSize.X and pt.Y <= rectPos.Y + rectSize.Y
end

-- handle clicks for sidebar and controls
function UI:_handleClick(mousePos)
    -- check tabs on sidebar
    local sidebarX = self.pos.X
    local sidebarY = self.pos.Y + 40
    local tabHeight = 28
    for i,tab in ipairs(self.tabs) do
        local tPos = Vector2.new(sidebarX + 12, sidebarY + (i-1) * (tabHeight + 8))
        local tSize = Vector2.new(160, tabHeight)
        if self:_pointInRect(mousePos, tPos, tSize) then
            self.activeTab = tab
            return
        end
    end

    -- check content controls
    if not self.activeTab then return end
    local contentStart = Vector2.new(self.pos.X + 200, self.pos.Y + 34)
    local cursor = Vector2.new(contentStart.X, contentStart.Y)
    local spacing = 32
    for _,item in ipairs(self.activeTab.children) do
        if item.type == "button" then
            local bPos = cursor
            local bSize = Vector2.new(220, 26)
            if self:_pointInRect(mousePos, bPos, bSize) then
                if item.cb then
                    local success,err = pcall(function() item.cb() end)
                    if not success then warn("Button callback error:",err) end
                end
                return
            end
            cursor = cursor + Vector2.new(0, spacing)
        elseif item.type == "toggle" then
            local tPos = cursor
            local tSize = Vector2.new(220, 20)
            -- toggle area on the right
            local toggleRect = Vector2.new(self.pos.X + self.size.X - 160, tPos.Y - 6)
            local toggleSize = Vector2.new(36, 16)
            if self:_pointInRect(mousePos, toggleRect, toggleSize) then
                item.state = not item.state
                if item.cb then
                    pcall(item.cb, item.state)
                end
                return
            end
            cursor = cursor + Vector2.new(0, spacing)
        elseif item.type == "slider" then
            local sPos = cursor
            local sSize = Vector2.new(320, 22)
            local sliderRect = Vector2.new(sPos.X + 8, sPos.Y + 6)
            local sliderSize = Vector2.new(260, 10)
            if self:_pointInRect(mousePos, sliderRect, sliderSize) then
                local rel = (mousePos.X - sliderRect.X) / sliderSize.X
                rel = clamp(rel, 0, 1)
                local newVal = item.min + (item.max - item.min) * rel
                item.value = newVal
                if item.cb then pcall(item.cb, newVal) end
                return
            end
            cursor = cursor + Vector2.new(0, spacing)
        end
    end
end

-- Render loop
function UI:_startRender()
    RunService.RenderStepped:Connect(function()
        self:_render()
    end)
end

-- internal render
function UI:_render()
    -- update main rects pos/size
    self.canvas.bg.Position = self.pos
    self.canvas.bg.Size = self.size

    self.canvas.sidebar.Position = self.pos
    self.canvas.sidebar.Size = Vector2.new(180, self.size.Y)

    self.canvas.title.Position = Vector2.new(self.pos.X + 12, self.pos.Y + 6)

    self.canvas.saveIcon.Position = Vector2.new(self.pos.X + self.size.X - 24, self.pos.Y + 14)
    self.canvas.gearIcon.Position = Vector2.new(self.pos.X + self.size.X - 46, self.pos.Y + 14)

    self.canvas.content.Position = Vector2.new(self.pos.X + 200, self.pos.Y + 30)
    self.canvas.content.Size = Vector2.new(self.size.X - 220, self.size.Y - 44)

    -- sidebar tabs
    for i,tab in ipairs(self.tabs) do
        local txt = self.canvas.tabTexts[i]
        local textPos = Vector2.new(self.pos.X + 12, self.pos.Y + 40 + (i-1)*36)
        if not txt then
            txt = DrawingAPI.newText()
            txt.Font = 3 -- UI font style
            self.canvas.tabTexts[i] = txt
        end
        txt.Text = tab.name
        txt.Position = textPos
        txt.Size = 20
        txt.Color = (tab == self.activeTab) and self.theme.Accent or self.theme.Text
    end

    -- draw content for active tab
    if self.activeTab then
        -- We'll render each child sequentially
        local start = Vector2.new(self.pos.X + 212, self.pos.Y + 44)
        local cursor = start
        local spacing = 36
        for _,item in ipairs(self.activeTab.children) do
            if item.type == "button" then
                -- background rect (button)
                if not item._rect then
                    item._rect = DrawingAPI.newRect()
                end
                local rect = item._rect
                rect.Position = cursor
                rect.Size = Vector2.new(220, 26)
                rect.Color = self.theme.PanelAccent
                rect.Transparency = 1
                rect.Filled = true
                rect.Visible = true

                -- text
                if not item._text then
                    item._text = DrawingAPI.newText()
                end
                item._text.Text = item.label
                item._text.Position = cursor + Vector2.new(8, 3)
                item._text.Size = 16
                item._text.Color = self.theme.Text

                cursor = cursor + Vector2.new(0, spacing)
            elseif item.type == "toggle" then
                -- label
                if not item._text then
                    item._text = DrawingAPI.newText()
                end
                item._text.Text = item.label
                item._text.Position = cursor + Vector2.new(0, 0)
                item._text.Size = 16
                item._text.Color = self.theme.Text

                -- toggle box (right side)
                if not item._box then
                    item._box = DrawingAPI.newRect()
                    item._dot = DrawingAPI.newCircle()
                end
                local boxPos = Vector2.new(self.pos.X + self.size.X - 160, cursor.Y - 6)
                item._box.Position = boxPos
                item._box.Size = Vector2.new(36, 16)
                item._box.Color = item.state and self.theme.Accent or self.theme.Highlight
                item._box.Filled = true

                item._dot.Position = Vector2.new(boxPos.X + (item.state and 24 or 12), boxPos.Y + 8)
                item._dot.Radius = 6
                item._dot.Color = Color3.new(1,1,1)

                cursor = cursor + Vector2.new(0, spacing)
            elseif item.type == "slider" then
                -- label
                if not item._text then
                    item._text = DrawingAPI.newText()
                end
                item._text.Text = string.format("%s: %0.2f", item.label, tonumber(item.value) or 0)
                item._text.Position = cursor + Vector2.new(0, -2)
                item._text.Size = 16
                item._text.Color = self.theme.Text

                -- slider bar
                if not item._bar then
                    item._bar = DrawingAPI.newRect()
                    item._fill = DrawingAPI.newRect()
                    item._knob = DrawingAPI.newCircle()
                end
                local barPos = Vector2.new(cursor.X + 8, cursor.Y + 18)
                local barSize = Vector2.new(260, 8)
                item._bar.Position = barPos
                item._bar.Size = barSize
                item._bar.Color = self.theme.Highlight
                item._bar.Filled = true

                local t = (item.value - item.min) / (item.max - item.min)
                t = clamp(t, 0, 1)
                item._fill.Position = barPos
                item._fill.Size = Vector2.new(math.max(6, barSize.X * t), barSize.Y)
                item._fill.Color = self.theme.SliderFill
                item._fill.Filled = true

                item._knob.Position = Vector2.new(barPos.X + barSize.X * t, barPos.Y + barSize.Y/2)
                item._knob.Radius = 7
                item._knob.Color = self.theme.Accent

                cursor = cursor + Vector2.new(0, spacing)
            end
        end
    end

    -- resizer visual
    local resPos = self.pos + self.size - Vector2.new(self.resizerSize, self.resizerSize)
    if not self.canvas.resizer then
        self.canvas.resizer = DrawingAPI.newLine()
        self.canvas.resizer2 = DrawingAPI.newLine()
        self.canvas.resizer3 = DrawingAPI.newLine()
    end
    local lineOffset = 5
    self.canvas.resizer.From = Vector2.new(resPos.X + lineOffset, resPos.Y + self.resizerSize - 4)
    self.canvas.resizer.To = Vector2.new(resPos.X + self.resizerSize - 4, resPos.Y + lineOffset)
    self.canvas.resizer.Color = self.theme.PanelAccent
    self.canvas.resizer.Thickness = 2

    -- small diagonal lines to imply resizer
    self.canvas.resizer2.From = Vector2.new(resPos.X + lineOffset + 6, resPos.Y + self.resizerSize - 4)
    self.canvas.resizer2.To = Vector2.new(resPos.X + self.resizerSize - 4, resPos.Y + lineOffset + 6)
    self.canvas.resizer2.Color = self.theme.PanelAccent
    self.canvas.resizer2.Thickness = 2

    -- bring important visuals to visible
    self.canvas.bg.Visible = true
    self.canvas.sidebar.Visible = true
    self.canvas.content.Visible = true
    self.canvas.title.Visible = true
    self.canvas.saveIcon.Visible = true
    self.canvas.gearIcon.Visible = true
end

-- Example builder (recreate a similar layout to the screenshot)
-- You can call these in your script after creating the UI to populate tabs.
function UI:PopulateExample()
    local main = self:CreateTab("Main")
    main:AddToggle("Enabled", true, function(state) print("Enabled:",state) end)
    main:AddToggle("Fake lag", false, function(v) print("Fake lag:",v) end)
    main:AddSlider("Edge yaw", 0, 360, 60, function(v) end)
    main:AddButton("Save", function() print("Save button pressed") end)

    local misc = self:CreateTab("Misc")
    misc:AddToggle("Slow motion", false, function(v) end)
    misc:AddSlider("Amount", 0, 100, 30, function(v) end)
    misc:AddButton("Apply", function() print("Apply pressed") end)

    local lua = self:CreateTab("Lua")
    lua:AddButton("Open Script Folder", function() print("open scripts") end)
end

-- Usage:
-- local lib = require(...) or loadstring(...) -> UI.new()
-- Example below:

-- return UI as module-like
local module = {}
module.new = function(opts)
    return UI.new(opts)
end

-- If this file is run directly: spawn an instance for demonstration
-- (This allows copy/paste usage - remove the demo if integrating into a module)
do
    local lib = UI.new({title = "GAMESENSE", pos = Vector2.new(60,40), size = Vector2.new(900,540)})
    lib:PopulateExample()
    -- Optional: expose instance to global for debugging
    _G.GamesenseUI = lib
end

return module
