-- LocalScript in StarterPlayerScripts

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")

local MAIL_PACKAGE_NAME = "Mail Package"
local REACH_DISTANCE = 4 -- distance from package pivot to consider "reached"
local MAX_PATH_DISTANCE = 500 -- don't bother with super-far targets

-- Pathfinding agent settings
local PATH_PARAMS = {
    AgentRadius = 2,
    AgentHeight = 5,
    AgentCanJump = true,
    AgentCanClimb = true
}

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- ðŸ” Remove existing UI if script injected multiple times
do
    local existingGui = playerGui:FindFirstChild("MailFetcherUI")
    if existingGui then
        existingGui:Destroy()
    end
end

---------------------------------------------------------------------
-- UI CREATION
---------------------------------------------------------------------

local consoleLabel
local consoleScroll

local logLines = {}
local MAX_LINES = 100 -- lines kept in console buffer

local function createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MailFetcherUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    -- Main panel
    local frame = Instance.new("Frame")
    frame.Name = "MainPanel"
    frame.AnchorPoint = Vector2.new(1, 1)
    frame.Position = UDim2.new(1, -20, 1, -20) -- bottom-right
    frame.Size = UDim2.new(0, 280, 0, 160)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BackgroundTransparency = 0.1
    frame.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 1.5
    stroke.Transparency = 0.3
    stroke.Parent = frame

    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -20, 0, 24)
    title.Position = UDim2.new(0, 10, 0, 8)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.Text = "Mail Fetcher"
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextColor3 = Color3.fromRGB(230, 230, 230)
    title.Parent = frame

    -- Fetch button
    local fetchButton = Instance.new("TextButton")
    fetchButton.Name = "FetchButton"
    fetchButton.Size = UDim2.new(1, -20, 0, 30)
    fetchButton.Position = UDim2.new(0, 10, 0, 40)
    fetchButton.BackgroundColor3 = Color3.fromRGB(40, 120, 255)
    fetchButton.AutoButtonColor = true
    fetchButton.Font = Enum.Font.GothamSemibold
    fetchButton.TextSize = 14
    fetchButton.Text = "Fetch Nearest Mail Package"
    fetchButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    fetchButton.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 8)
    btnCorner.Parent = fetchButton

    local btnStroke = Instance.new("UIStroke")
    btnStroke.Thickness = 1
    btnStroke.Transparency = 0.3
    btnStroke.Parent = fetchButton

    -- Console background
    local consoleFrame = Instance.new("Frame")
    consoleFrame.Name = "ConsoleFrame"
    consoleFrame.Size = UDim2.new(1, -20, 0, 70)
    consoleFrame.Position = UDim2.new(0, 10, 0, 80)
    consoleFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    consoleFrame.BackgroundTransparency = 0.2
    consoleFrame.Parent = frame

    local consoleCorner = Instance.new("UICorner")
    consoleCorner.CornerRadius = UDim.new(0, 8)
    consoleCorner.Parent = consoleFrame

    local consoleStroke = Instance.new("UIStroke")
    consoleStroke.Thickness = 1
    consoleStroke.Transparency = 0.5
    consoleStroke.Parent = consoleFrame

    -- Scrolling console
    local scroll = Instance.new("ScrollingFrame")
    scroll.Name = "ConsoleScroll"
    scroll.Size = UDim2.new(1, -10, 1, -10)
    scroll.Position = UDim2.new(0, 5, 0, 5)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 4
    scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    scroll.ScrollBarImageTransparency = 0.2
    scroll.Parent = consoleFrame

    local console = Instance.new("TextLabel")
    console.Name = "Console"
    console.Size = UDim2.new(1, -4, 0, 0) -- height via TextBounds
    console.Position = UDim2.new(0, 2, 0, 0)
    console.BackgroundTransparency = 1
    console.Font = Enum.Font.Code
    console.TextSize = 12
    console.TextXAlignment = Enum.TextXAlignment.Left
    console.TextYAlignment = Enum.TextYAlignment.Top
    console.TextWrapped = false
    console.Text = ""
    console.TextColor3 = Color3.fromRGB(200, 200, 200)
    console.Parent = scroll

    consoleLabel = console
    consoleScroll = scroll

    return fetchButton
end

-- logging helper for console (with auto-scroll, no errors)
local function log(msg)
    if not consoleLabel or not consoleScroll then
        return
    end

    msg = tostring(msg)

    table.insert(logLines, os.date("[%H:%M:%S] ") .. msg)
    if #logLines > MAX_LINES then
        table.remove(logLines, 1)
    end

    consoleLabel.Text = table.concat(logLines, "\n")

    local textHeight = consoleLabel.TextBounds.Y
    if textHeight < 0 then textHeight = 0 end

    consoleLabel.Size = UDim2.new(1, -4, 0, textHeight)
    consoleScroll.CanvasSize = UDim2.new(0, 0, 0, textHeight)

    local windowHeight = consoleScroll.AbsoluteWindowSize.Y
    if windowHeight <= 0 then windowHeight = 1 end

    local y = math.max(0, textHeight - windowHeight)
    consoleScroll.CanvasPosition = Vector2.new(0, y)
end

---------------------------------------------------------------------
-- CORE MAIL PACKAGE / PATHFINDING LOGIC
---------------------------------------------------------------------

local function getCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then
        log("No character found.")
        return nil
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid", 5)
    local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 5)

    if not humanoid or not hrp then
        log("Humanoid or HumanoidRootPart missing.")
        return nil
    end

    return character, humanoid, hrp
end

-- Find main BasePart from a model
local function getMainPartFromModel(model)
    if not model or not model:IsA("Model") then
        return nil
    end
    if model.PrimaryPart then
        return model.PrimaryPart
    end
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BasePart") then
            return desc
        end
    end
    return nil
end

-- Get all "Mail Package" models sorted by distance
local function getMailPackagesSortedByDistance(hrp)
    local results = {}

    for _, inst in ipairs(workspace:GetDescendants()) do
        if inst:IsA("Model") and inst.Name == MAIL_PACKAGE_NAME then
            local ok, pivot = pcall(function()
                return inst:GetPivot()
            end)
            if ok and pivot then
                local dist = (pivot.Position - hrp.Position).Magnitude
                table.insert(results, {model = inst, distance = dist, pivot = pivot})
            end
        end
    end

    table.sort(results, function(a, b)
        return a.distance < b.distance
    end)

    return results
end

-- Make the humanoid walk along a path to a target position (robust)
local function walkToPosition(humanoid, hrp, targetPos)
    if not humanoid or not hrp or not targetPos then
        log("walkToPosition: missing humanoid/hrp/targetPos.")
        return false
    end

    local startPos = hrp.Position
    local flatTarget = Vector3.new(targetPos.X, startPos.Y, targetPos.Z)

    log(("Computing path from (%.1f, %.1f, %.1f) to (%.1f, %.1f, %.1f)..."):format(
        startPos.X, startPos.Y, startPos.Z,
        flatTarget.X, flatTarget.Y, flatTarget.Z
    ))

    local path = PathfindingService:CreatePath(PATH_PARAMS)
    local okCompute, _ = pcall(function()
        path:ComputeAsync(startPos, flatTarget)
    end)

    if not okCompute then
        log("Path:ComputeAsync threw an error.")
        return false
    end

    local status = path.Status
    log("Path status: " .. tostring(status))

    if status ~= Enum.PathStatus.Success then
        log("Pathfinding failed (no valid path).")
        return false
    end

    local waypoints = path:GetWaypoints()
    if not waypoints or #waypoints == 0 then
        log("Path has no waypoints.")
        return false
    end

    log("Path computed. Following " .. #waypoints .. " waypoints...")

    for i, waypoint in ipairs(waypoints) do
        if not humanoid or humanoid.Health <= 0 then
            log("Humanoid invalid or dead; stopping path.")
            return false
        end

        humanoid:MoveTo(waypoint.Position)
        log("Moving to waypoint " .. i .. "/" .. #waypoints)

        local reached = humanoid.MoveToFinished:Wait()
        if not reached then
            log("Failed to reach waypoint " .. i .. " (MoveToFinished=false)")
            return false
        end
    end

    log("Arrived near target position.")
    return true
end

-- Attach/weld the package model to the character when we reach it
local function pickUpMailPackage(mailPackage, hrp)
    if not mailPackage or not mailPackage.Parent then
        log("pickUpMailPackage: package missing or removed.")
        return
    end

    local mainPart = getMainPartFromModel(mailPackage)
    if not mainPart then
        log("Mail Package has no BasePart to weld.")
        return
    end

    for _, desc in ipairs(mailPackage:GetDescendants()) do
        if desc:IsA("BasePart") then
            desc.Anchored = false
            desc.CanCollide = false
        end
    end

    if not mailPackage.PrimaryPart then
        mailPackage.PrimaryPart = mainPart
    end

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hrp
    weld.Part1 = mainPart
    weld.Parent = mainPart

    mailPackage:PivotTo(hrp.CFrame * CFrame.new(0, 0, -2))

    log("Picked up Mail Package: " .. mailPackage:GetFullName())
end

local isBusy = false

local function findWalkAndPickup()
    if isBusy then
        log("Already fetching a Mail Package...")
        return
    end

    isBusy = true
    log("Starting fetch operation...")

    local character, humanoid, hrp = getCharacter()
    if not character then
        log("Cannot start fetch: character invalid.")
        isBusy = false
        return
    end

    log("Searching for '" .. MAIL_PACKAGE_NAME .. "' models...")
    local candidates = getMailPackagesSortedByDistance(hrp)

    if #candidates == 0 then
        log("No 'Mail Package' models found in workspace.")
        isBusy = false
        return
    end

    log("Found " .. #candidates .. " Mail Package(s). Trying nearest reachable...")

    local picked = false

    for index, entry in ipairs(candidates) do
        local mailPackage = entry.model
        local dist = entry.distance
        local pivotCFrame = entry.pivot

        if not mailPackage or not mailPackage.Parent then
            log("Candidate #" .. index .. " removed, skipping.")
            continue
        end

        log(("[#%d] Mail Package at distance: %.1f studs"):format(index, dist))

        if dist > MAX_PATH_DISTANCE then
            log("Too far (beyond MAX_PATH_DISTANCE), skipping this and remaining.")
            break
        end

        local success = walkToPosition(humanoid, hrp, pivotCFrame.Position)
        if success then
            local finalDist = (mailPackage:GetPivot().Position - hrp.Position).Magnitude
            log(("Reached candidate #%d (final distance: %.1f studs)."):format(index, finalDist))

            if finalDist <= REACH_DISTANCE then
                log("Within reach. Picking up...")
                pickUpMailPackage(mailPackage, hrp)
                picked = true
                break
            else
                log("Not close enough after walking, trying next candidate if available.")
            end
        else
            log("Path failed for candidate #" .. index .. ", trying next if available.")
        end
    end

    if not picked then
        log("No reachable Mail Package could be picked up.")
    end

    isBusy = false
end

---------------------------------------------------------------------
-- BOOTSTRAP
---------------------------------------------------------------------

local fetchButton = createUI()
log("Mail Fetcher UI initialized.")
log("Click the button to fetch the nearest Mail Package.")

fetchButton.MouseButton1Click:Connect(function()
    task.spawn(findWalkAndPickup)
end)

player.CharacterAdded:Connect(function()
    task.wait(1)
    log("Character respawned. Ready to fetch Mail Packages.")
end)
