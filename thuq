-- LocalScript in StarterPlayerScripts

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")

local MAIL_PACKAGE_NAME = "Mail Package"
local REACH_DISTANCE = 4 -- distance from target to count as "reached"

-- Always move to this world pivot:
local TARGET_WORLD_PIVOT = Vector3.new(-159.037, 296.728, 212.685)

-- Pathfinding agent settings
local PATH_PARAMS = {
    AgentRadius = 2,
    AgentHeight = 5,
    AgentCanJump = true,
    AgentCanClimb = true
}

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- ðŸ” Remove existing UI if script injected multiple times
do
    local existingGui = playerGui:FindFirstChild("MailFetcherUI")
    if existingGui then
        existingGui:Destroy()
    end
end

---------------------------------------------------------------------
-- UI CREATION
---------------------------------------------------------------------

local consoleLabel
local consoleScroll

local logLines = {}
local MAX_LINES = 100 -- lines kept in console buffer

local function createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MailFetcherUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    -- Main panel
    local frame = Instance.new("Frame")
    frame.Name = "MainPanel"
    frame.AnchorPoint = Vector2.new(1, 1)
    frame.Position = UDim2.new(1, -20, 1, -20) -- bottom-right
    frame.Size = UDim2.new(0, 280, 0, 160)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BackgroundTransparency = 0.1
    frame.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 1.5
    stroke.Transparency = 0.3
    stroke.Parent = frame

    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -20, 0, 24)
    title.Position = UDim2.new(0, 10, 0, 8)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.Text = "Mail Fetcher"
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextColor3 = Color3.fromRGB(230, 230, 230)
    title.Parent = frame

    -- Fetch button
    local fetchButton = Instance.new("TextButton")
    fetchButton.Name = "FetchButton"
    fetchButton.Size = UDim2.new(1, -20, 0, 30)
    fetchButton.Position = UDim2.new(0, 10, 0, 40)
    fetchButton.BackgroundColor3 = Color3.fromRGB(40, 120, 255)
    fetchButton.AutoButtonColor = true
    fetchButton.Font = Enum.Font.GothamSemibold
    fetchButton.TextSize = 14
    fetchButton.Text = "Move to Mail Pivot & Pick Up"
    fetchButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    fetchButton.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 8)
    btnCorner.Parent = fetchButton

    local btnStroke = Instance.new("UIStroke")
    btnStroke.Thickness = 1
    btnStroke.Transparency = 0.3
    btnStroke.Parent = fetchButton

    -- Console background
    local consoleFrame = Instance.new("Frame")
    consoleFrame.Name = "ConsoleFrame"
    consoleFrame.Size = UDim2.new(1, -20, 0, 70)
    consoleFrame.Position = UDim2.new(0, 10, 0, 80)
    consoleFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    consoleFrame.BackgroundTransparency = 0.2
    consoleFrame.Parent = frame

    local consoleCorner = Instance.new("UICorner")
    consoleCorner.CornerRadius = UDim.new(0, 8)
    consoleCorner.Parent = consoleFrame

    local consoleStroke = Instance.new("UIStroke")
    consoleStroke.Thickness = 1
    consoleStroke.Transparency = 0.5
    consoleStroke.Parent = consoleFrame

    -- Scrolling console
    local scroll = Instance.new("ScrollingFrame")
    scroll.Name = "ConsoleScroll"
    scroll.Size = UDim2.new(1, -10, 1, -10)
    scroll.Position = UDim2.new(0, 5, 0, 5)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 4
    scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    scroll.ScrollBarImageTransparency = 0.2
    scroll.Parent = consoleFrame

    local console = Instance.new("TextLabel")
    console.Name = "Console"
    console.Size = UDim2.new(1, -4, 0, 0) -- height via TextBounds
    console.Position = UDim2.new(0, 2, 0, 0)
    console.BackgroundTransparency = 1
    console.Font = Enum.Font.Code
    console.TextSize = 12
    console.TextXAlignment = Enum.TextXAlignment.Left
    console.TextYAlignment = Enum.TextYAlignment.Top
    console.TextWrapped = false
    console.Text = ""
    console.TextColor3 = Color3.fromRGB(200, 200, 200)
    console.Parent = scroll

    consoleLabel = console
    consoleScroll = scroll

    return fetchButton
end

-- logging helper for console (with auto-scroll)
local function log(msg)
    if not consoleLabel or not consoleScroll then
        return
    end

    msg = tostring(msg)

    table.insert(logLines, os.date("[%H:%M:%S] ") .. msg)
    if #logLines > MAX_LINES then
        table.remove(logLines, 1)
    end

    consoleLabel.Text = table.concat(logLines, "\n")

    local textHeight = consoleLabel.TextBounds.Y
    if textHeight < 0 then textHeight = 0 end

    consoleLabel.Size = UDim2.new(1, -4, 0, textHeight)
    consoleScroll.CanvasSize = UDim2.new(0, 0, 0, textHeight)

    local windowHeight = consoleScroll.AbsoluteWindowSize.Y
    if windowHeight <= 0 then windowHeight = 1 end

    local y = math.max(0, textHeight - windowHeight)
    consoleScroll.CanvasPosition = Vector2.new(0, y)
end

---------------------------------------------------------------------
-- CORE LOGIC
---------------------------------------------------------------------

local function getCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then
        log("No character found.")
        return nil
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid", 5)
    local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 5)

    if not humanoid or not hrp then
        log("Humanoid or HumanoidRootPart missing.")
        return nil
    end

    return character, humanoid, hrp
end

-- Find main BasePart from a model
local function getMainPartFromModel(model)
    if not model or not model:IsA("Model") then
        return nil
    end
    if model.PrimaryPart then
        return model.PrimaryPart
    end
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BasePart") then
            return desc
        end
    end
    return nil
end

-- Get *nearest* Mail Package to the player (by pivot distance)
local function getNearestMailPackage(hrp)
    local nearestModel
    local nearestDist = math.huge

    for _, inst in ipairs(workspace:GetDescendants()) do
        if inst:IsA("Model") and inst.Name == MAIL_PACKAGE_NAME then
            local ok, pivot = pcall(function()
                return inst:GetPivot()
            end)
            if ok and pivot then
                local dist = (pivot.Position - hrp.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearestModel = inst
                end
            end
        end
    end

    return nearestModel, nearestDist
end

-- Robust path + fallback straight-line walking
local function walkToPosition(humanoid, hrp, targetPos)
    if not humanoid or not hrp or not targetPos then
        log("walkToPosition: missing humanoid/hrp/targetPos.")
        return false
    end

    local startPos = hrp.Position

    log(("Path step: from (%.1f, %.1f, %.1f) to (%.1f, %.1f, %.1f)"):format(
        startPos.X, startPos.Y, startPos.Z,
        targetPos.X, targetPos.Y, targetPos.Z
    ))

    ----------------------------------------------------------------
    -- 1) Try Roblox pathfinding
    ----------------------------------------------------------------
    local path = PathfindingService:CreatePath(PATH_PARAMS)

    local okCompute = pcall(function()
        path:ComputeAsync(startPos, targetPos)
    end)

    if okCompute then
        local status = path.Status
        log("Path status: " .. tostring(status))

        if status == Enum.PathStatus.Success then
            local waypoints = path:GetWaypoints()
            if waypoints and #waypoints > 0 then
                log("Path computed. Following " .. #waypoints .. " waypoints...")
                for i, waypoint in ipairs(waypoints) do
                    if not humanoid or humanoid.Health <= 0 then
                        log("Humanoid invalid or dead; stopping path.")
                        return false
                    end

                    humanoid:MoveTo(waypoint.Position)
                    log("Moving to waypoint " .. i .. "/" .. #waypoints)
                    local reached = humanoid.MoveToFinished:Wait()
                    if not reached then
                        log("Failed to reach waypoint " .. i .. "; stopping path.")
                        break
                    end
                end
            else
                log("Path has no waypoints; skipping to fallback.")
            end
        else
            log("Pathfinding could not find a valid path; using fallback.")
        end
    else
        log("Path:ComputeAsync threw an error; using fallback.")
    end

    ----------------------------------------------------------------
    -- 2) Fallback: straight-line walking in steps using MoveTo
    ----------------------------------------------------------------
    log("Fallback: walking directly towards target in steps.")

    local MAX_STEPS = 100
    local STEP_DISTANCE = 8

    for step = 1, MAX_STEPS do
        if not humanoid or humanoid.Health <= 0 then
            log("Humanoid invalid or dead; stopping fallback.")
            return false
        end

        local currentPos = hrp.Position
        local diff = targetPos - currentPos
        local distance = diff.Magnitude

        if distance <= REACH_DISTANCE then
            log(("Fallback: reached target (%.1f studs away)."):format(distance))
            return true
        end

        local direction = diff.Unit
        local nextPos = currentPos + direction * math.min(STEP_DISTANCE, distance)

        humanoid:MoveTo(nextPos)
        log(("Fallback: step %d, moving closer (remaining: %.1f studs)"):format(step, distance))

        humanoid.MoveToFinished:Wait()
    end

    local finalDist = (targetPos - hrp.Position).Magnitude
    log(("Fallback finished; final distance to target: %.1f studs"):format(finalDist))

    return finalDist <= REACH_DISTANCE
end

-- Attach/weld the package model to the character
local function pickUpMailPackage(mailPackage, hrp)
    if not mailPackage or not mailPackage.Parent then
        log("pickUpMailPackage: package missing or removed.")
        return
    end

    local mainPart = getMainPartFromModel(mailPackage)
    if not mainPart then
        log("Mail Package has no BasePart to weld.")
        return
    end

    for _, desc in ipairs(mailPackage:GetDescendants()) do
        if desc:IsA("BasePart") then
            desc.Anchored = false
            desc.CanCollide = false
        end
    end

    if not mailPackage.PrimaryPart then
        mailPackage.PrimaryPart = mainPart
    end

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hrp
    weld.Part1 = mainPart
    weld.Parent = mainPart

    mailPackage:PivotTo(hrp.CFrame * CFrame.new(0, 0, -2))

    log("Picked up Mail Package: " .. mailPackage:GetFullName())
end

local isBusy = false

local function moveToPivotAndPickup()
    if isBusy then
        log("Already running a fetch operation...")
        return
    end

    isBusy = true
    log("Starting operation: move to fixed world pivot and pick up mail.")

    local character, humanoid, hrp = getCharacter()
    if not character then
        log("Cannot start: character invalid.")
        isBusy = false
        return
    end

    local distToPivot = (TARGET_WORLD_PIVOT - hrp.Position).Magnitude
    log(("Distance to target world pivot: %.1f studs"):format(distToPivot))

    local success = walkToPosition(humanoid, hrp, TARGET_WORLD_PIVOT)
    if not success then
        local finalDist = (TARGET_WORLD_PIVOT - hrp.Position).Magnitude
        log(("Could not fully reach target world pivot; final distance: %.1f studs"):format(finalDist))
        -- we still continue; maybe close enough to mail package
    else
        log("Reached target world pivot (or close enough).")
    end

    -- After movement, look for nearest Mail Package and pick it up
    local mailPackage, packageDist = getNearestMailPackage(hrp)
    if not mailPackage then
        log("No 'Mail Package' found near pivot.")
        isBusy = false
        return
    end

    log(("Nearest Mail Package after arrival is %.1f studs away."):format(packageDist))

    if packageDist <= REACH_DISTANCE * 2 then
        log("Within pickup range. Picking up Mail Package...")
        pickUpMailPackage(mailPackage, hrp)
    else
        log("Mail Package is still too far to pick up.")
    end

    isBusy = false
end

---------------------------------------------------------------------
-- BOOTSTRAP
---------------------------------------------------------------------

local fetchButton = createUI()
log("Mail Fetcher UI initialized.")
log(("Target world pivot: (%.3f, %.3f, %.3f)"):format(
    TARGET_WORLD_PIVOT.X, TARGET_WORLD_PIVOT.Y, TARGET_WORLD_PIVOT.Z
))
log("Click the button to move there and pick up the nearest Mail Package.")

fetchButton.MouseButton1Click:Connect(function()
    task.spawn(moveToPivotAndPickup)
end)

player.CharacterAdded:Connect(function()
    task.wait(1)
    log("Character respawned. Ready to move to pivot & fetch mail.")
end)
